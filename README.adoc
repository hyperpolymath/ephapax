image:https://img.shields.io/badge/license-PMPL--1.0-blue.svg[License,link="https://github.com/hyperpolymath/palimpsest-license"]
image:https://img.shields.io/badge/Philosophy-Palimpsest-purple.svg[Palimpsest,link="https://github.com/hyperpolymath/palimpsest-licence"]


// SPDX-License-Identifier: PMPL-1.0
// SPDX-FileCopyrightText: 2025 Jonathan D.A. Jewell
:toc: macro
:toclevels: 3
:icons: font
:source-highlighter: rouge
:experimental:

= Ephapax



_á¼Ï†Î¬Ï€Î±Î¾ â€” once for all_

image:https://img.shields.io/badge/rust-1.83+-orange.svg[Rust 1.83+]
image:https://img.shields.io/badge/coq-8.18+-red.svg[Coq 8.18+]
image:https://img.shields.io/badge/target-wasm32-purple.svg[WASM]

A linear type system for safe memory management targeting WebAssembly.

toc::[]

== Overview

Ephapax is a programming language with a linear type system that guarantees:

[cols="1,3"]
|===
| Guarantee | Mechanism

| **No use-after-free**
| Linear resources cannot be accessed after consumption

| **No memory leaks**
| Linear resources must be consumed exactly once

| **Region-based deallocation**
| Bulk memory management without garbage collection

| **Zero-cost abstractions**
| Safety guarantees enforced at compile time
|===

== Design Principles

[cols="1,3"]
|===
| Principle | Mechanism

| **Linearity**
| Every linear value used exactly once

| **Regions**
| Scoped allocation with bulk deallocation

| **Second-class borrows**
| Temporary access without ownership transfer

| **Explicit copies**
| Duplication requires explicit syntax
|===

== Example

[source,ephapax]
----
region r:
    let s1 = String.new@r("hello, ")
    let s2 = String.new@r("world")

    -- Borrow s1 to get length (does not consume)
    let len = String.len(&s1)

    -- Concatenation consumes both strings
    let result = String.concat(s1, s2)

    -- result is consumed by returning
    result
-- Region exits: any remaining allocations freed
----

== Project Structure

[source]
----
ephapax/
â”œâ”€â”€ formal/              # Coq formalisation of type system
â”‚   â”œâ”€â”€ Syntax.v         # AST and types
â”‚   â”œâ”€â”€ Typing.v         # Linear typing rules
â”‚   â””â”€â”€ Semantics.v      # Operational semantics & soundness
â”œâ”€â”€ src/                 # Implementation
â”‚   â”œâ”€â”€ ephapax-syntax/  # AST definitions
â”‚   â”œâ”€â”€ ephapax-typing/  # Linear type checker
â”‚   â”œâ”€â”€ ephapax-lexer/   # Tokenizer (logos)
â”‚   â”œâ”€â”€ ephapax-parser/  # Parser (chumsky)
â”‚   â”œâ”€â”€ ephapax-interp/  # Tree-walking interpreter
â”‚   â”œâ”€â”€ ephapax-wasm/    # WASM code generation
â”‚   â”œâ”€â”€ ephapax-runtime/ # Runtime support
â”‚   â”œâ”€â”€ ephapax-repl/    # Interactive shell
â”‚   â””â”€â”€ ephapax-cli/     # Command-line interface
â”œâ”€â”€ conformance/         # Type system conformance tests
â”‚   â”œâ”€â”€ pass/            # Programs that should type-check
â”‚   â””â”€â”€ fail/            # Programs that should be rejected
â”œâ”€â”€ spec/                # Language specification
â”œâ”€â”€ .machine_read/       # Machine-readable specs for tooling
â””â”€â”€ docs/                # Documentation
----

== Build Targets

[cols="1,2,1"]
|===
| Target | Description | Status

| **WebAssembly**
| `wasm32-unknown-unknown`
| Primary

| **Native**
| Via Cranelift
| Secondary
|===

== Formal Foundations

The type system is grounded in:

* **Intuitionistic linear logic** â€” Resource-sensitive reasoning
* **Separation logic** â€” Memory ownership and framing
* **Region calculus (Tofte-Talpin)** â€” Scoped allocation

See `formal/` for Coq mechanisation.

== Quick Start

=== Prerequisites

* Rust 1.83+ with `wasm32-unknown-unknown` target
* Coq 8.18+ (optional, for proof verification)
* https://just.systems/[just] (task runner)

=== Build

[source,bash]
----
# Build all crates
just build

# Build for WASM
just build-wasm

# Build Idris2 affine stage
just idris-build

# Verify Coq proofs (optional, requires Coq 8.18+)
just proofs
----

=== Test

[source,bash]
----
# Run all tests
just test

# Run conformance test suite
just conformance

# Run golden path (test + build + proofs)
just golden
----

== Documentation

* link:spec/SPEC.md[Language Specification]
* link:docs/wiki/[Wiki Documentation]
* link:docs/coqdoc/[Coq Documentation] (generated)

== Two-Phase Compiler (Idris2 â†’ WASM)

Ephapax includes an experimental two-stage pipeline:

* **Stage 1 (Idris2)**: parse concrete Ephapax syntax (or S-expression IR) and type-check in affine or linear mode.
* **Stage 2 (Rust)**: compile the checked IR to WebAssembly.

Run:

[source,bash]
----
# Compile a module through Idris2 + WASM backend (concrete syntax)
just compile-affine input.eph affine output.wasm

# Compile an S-expression module through Idris2 + WASM backend
scripts/compile-affine.sh input.sexpr --mode affine --out output.wasm --sexpr

# Or call the CLI directly for Stage 2
cargo run -p ephapax-cli -- compile-sexpr input.sexpr -o output.wasm
----

=== Parser Tests & Bench

[source,bash]
----
# Run Idris2 parser tests
just idris-parse-test

# Benchmark Idris2 parser (parse-only)
just idris-parse-bench input.eph 10

# Build Zig token buffer (FFI)
scripts/build-zig-ffi.sh
----

== Status

ğŸš§ **Early Development**

[cols="1,1"]
|===
| Component | Status

| Core type system design
| âœ… Complete

| Formal semantics (Coq)
| âœ… Complete

| Lexer
| âœ… Complete

| Parser
| âœ… Complete

| Type checker
| ğŸš§ In Progress

| WASM code generation
| ğŸš§ In Progress

| Interpreter
| âœ… Complete

| REPL
| âœ… Complete

| CLI
| âœ… Complete

| Standard library
| ğŸ”² Planned
|===

== Related Work

* https://www.rust-lang.org/[Rust] â€” Ownership and borrowing
* https://ghc.gitlab.haskell.org/ghc/doc/users_guide/exts/linear_types.html[Linear Haskell] â€” Linear types in GHC
* https://www.cl.cam.ac.uk/research/mvg/tom/mlkit/[MLKit] â€” Region-based memory management
* https://cyclone.thelanguage.org/[Cyclone] â€” Safe C dialect with regions

== Contributing

Contributions are welcome! Please see:

* link:CONTRIBUTING.adoc[Contributing Guide]
* link:CODE_OF_CONDUCT.md[Code of Conduct]

== Licence

EUPL-1.2 â€” See link:LICENSE.txt[LICENSE.txt]

== Author

**Jonathan D.A. Jewell**

---

_"Once for all" â€” every resource used exactly once._
