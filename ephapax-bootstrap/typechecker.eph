// SPDX-License-Identifier: PMPL-1.0-or-later
// Ephapax Type Checker - Self-hosting compiler (written in Ephapax linear mode)
//
// This type checker enforces the dyadic type system (linear + affine modes)
// with explicit resource tracking and linearity validation.

// ============================================================================
// TYPE CHECKER CONTEXT
// ============================================================================

// Variable binding entry
type VarEntry = {
    name: String,
    ty: Type,
    used: Bool,        // Has this variable been used?
    is_linear: Bool,   // Is this a linear type?
}

// Type checking mode
type Mode =
    | ModeLinear    // Strict: all linear vars must be used exactly once
    | ModeAffine    // Permissive: linear vars can be implicitly dropped

// Type checker context
type Context = {
    vars: [VarEntry],      // Variable bindings
    mode: Mode,            // Current checking mode
}

// Type checking result
type TypeResult =
    | TypeOk(Type, Context)           // Success: (type, updated context)
    | TypeError(String, I32, I32)     // Error: (message, line, col)

// ============================================================================
// CONTEXT OPERATIONS
// ============================================================================

// Create empty context
fn empty_context(mode: Mode): Context =
    { vars: list_new(16)
    , mode: mode
    }

// Look up variable type
fn lookup_var(ctx: Context, name: String): TypeResult =
    lookup_var_loop(ctx, name, 0)

// Helper: loop through variable list
fn lookup_var_loop(ctx: Context, name: String, idx: I32): TypeResult =
    if idx >= list_len(ctx.vars) then
        let msg = String.concat(
            String.new@default("Unbound variable: "),
            name
        ) in
        TypeError(msg, 0, 0)
    else
        let entry = list_get(ctx.vars, idx) in
        if string_eq(entry.name, name) then
            TypeOk(entry.ty, ctx)
        else
            lookup_var_loop(ctx, name, idx + 1)

// Mark variable as used (for linear checking)
fn mark_used(ctx: Context, name: String): TypeResult =
    mark_used_loop(ctx, name, 0, list_new(16))

// Helper: rebuild var list with variable marked as used
fn mark_used_loop(ctx: Context, name: String, idx: I32, new_vars: [VarEntry]): TypeResult =
    if idx >= list_len(ctx.vars) then
        let msg = String.concat(
            String.new@default("Variable not found: "),
            name
        ) in
        TypeError(msg, 0, 0)
    else
        let entry = list_get(ctx.vars, idx) in
        if string_eq(entry.name, name) then
            // Found the variable
            if entry.is_linear && entry.used then
                // Linear variable already used!
                let msg = String.concat(
                    String.new@default("Linear variable used twice: "),
                    name
                ) in
                TypeError(msg, 0, 0)
            else
                // Mark as used
                let updated_entry = {
                    name: entry.name,
                    ty: entry.ty,
                    used: true,
                    is_linear: entry.is_linear
                } in
                let new_vars2 = list_append(new_vars, updated_entry) in
                // Copy remaining entries
                let final_vars = copy_remaining_vars(ctx.vars, idx + 1, new_vars2) in
                let new_ctx = { vars: final_vars, mode: ctx.mode } in
                TypeOk(entry.ty, new_ctx)
        else
            // Not this variable, keep going
            let new_vars2 = list_append(new_vars, entry) in
            mark_used_loop(ctx, name, idx + 1, new_vars2)

// Helper: copy remaining variables from old list to new list
fn copy_remaining_vars(old_vars: [VarEntry], start_idx: I32, new_vars: [VarEntry]): [VarEntry] =
    if start_idx >= list_len(old_vars) then
        new_vars
    else
        let entry = list_get(old_vars, start_idx) in
        let new_vars2 = list_append(new_vars, entry) in
        copy_remaining_vars(old_vars, start_idx + 1, new_vars2)

// Extend context with new variable binding
fn extend_context(ctx: Context, name: String, ty: Type): Context =
    let is_linear = is_linear_type(ty) in
    let entry = {
        name: name,
        ty: ty,
        used: false,
        is_linear: is_linear
    } in
    let new_vars = list_append(ctx.vars, entry) in
    { vars: new_vars, mode: ctx.mode }

// Check if all linear variables have been used (mode-aware)
fn check_all_linear_used(ctx: Context): TypeResult =
    if ctx.mode == ModeAffine then
        // In affine mode, unused linear vars are implicitly dropped
        TypeOk(TyUnit, ctx)
    else
        // In linear mode, all linear vars must be used
        check_linear_used_loop(ctx, 0)

// Helper: loop through vars checking linear ones are used
fn check_linear_used_loop(ctx: Context, idx: I32): TypeResult =
    if idx >= list_len(ctx.vars) then
        TypeOk(TyUnit, ctx)
    else
        let entry = list_get(ctx.vars, idx) in
        if entry.is_linear && !entry.used then
            let msg = String.concat(
                String.new@default("Linear variable not consumed: "),
                entry.name
            ) in
            TypeError(msg, 0, 0)
        else
            check_linear_used_loop(ctx, idx + 1)

// ============================================================================
// TYPE UTILITIES
// ============================================================================

// Check if a type is linear (must be used exactly once)
fn is_linear_type(ty: Type): Bool =
    case ty of
    | TyString -> true
    | TyList(_) -> true  // Lists are linear
    | TyFun(_, _) -> false
    | TyProd(t1, t2) -> is_linear_type(t1) || is_linear_type(t2)
    | TySum(t1, t2) -> is_linear_type(t1) || is_linear_type(t2)
    | _ -> false
    end

// Check type equality
fn type_eq(t1: Type, t2: Type): Bool =
    case t1 of
    | TyUnit ->
        case t2 of
        | TyUnit -> true
        | _ -> false
        end
    | TyBool ->
        case t2 of
        | TyBool -> true
        | _ -> false
        end
    | TyI32 ->
        case t2 of
        | TyI32 -> true
        | _ -> false
        end
    | TyI64 ->
        case t2 of
        | TyI64 -> true
        | _ -> false
        end
    | TyFun(p1, r1) ->
        case t2 of
        | TyFun(p2, r2) -> type_eq(p1, p2) && type_eq(r1, r2)
        | _ -> false
        end
    | TyProd(l1, r1) ->
        case t2 of
        | TyProd(l2, r2) -> type_eq(l1, l2) && type_eq(r1, r2)
        | _ -> false
        end
    | TyList(elem1) ->
        case t2 of
        | TyList(elem2) -> type_eq(elem1, elem2)
        | _ -> false
        end
    | _ -> false  // TODO: Other cases
    end

// ============================================================================
// EXPRESSION TYPE CHECKING
// ============================================================================

// Type check a literal
fn check_literal(ctx: Context, lit: Literal): TypeResult =
    case lit of
    | LitUnit -> TypeOk(TyUnit, ctx)
    | LitBool(_) -> TypeOk(TyBool, ctx)
    | LitI32(_) -> TypeOk(TyI32, ctx)
    | LitString(_) ->
        // String literals should be allocated with String.new@region
        TypeError(String.new@default("Unallocated string literal"), 0, 0)
    end

// Type check a variable reference
fn check_var(ctx: Context, name: String): TypeResult =
    case lookup_var(ctx, name) of
    | TypeOk(ty, ctx2) ->
        // Mark linear variables as used
        if is_linear_type(ty) then
            mark_used(ctx2, name)
        else
            TypeOk(ty, ctx2)
    | TypeError(msg, line, col) ->
        TypeError(msg, line, col)
    end

// Type check let binding: let x = e1 in e2
fn check_let(ctx: Context, name: String, value: Expr, body: Expr): TypeResult =
    case check_expr(ctx, value) of
    | TypeOk(value_ty, ctx2) ->
        // Extend context with new binding
        let ctx3 = extend_context(ctx2, name, value_ty) in
        // Check body
        case check_expr(ctx3, body) of
        | TypeOk(body_ty, ctx4) ->
            TypeOk(body_ty, ctx4)
        | TypeError(msg, line, col) ->
            TypeError(msg, line, col)
        end
    | TypeError(msg, line, col) ->
        TypeError(msg, line, col)
    end

// Type check linear let binding: let! x = e1 in e2
fn check_let_lin(ctx: Context, name: String, value: Expr, body: Expr): TypeResult =
    // Same as regular let (linearity tracked via type)
    check_let(ctx, name, value, body)

// Type check lambda: fn(x: T) -> e
fn check_lambda(ctx: Context, param: String, param_ty: Type, body: Expr): TypeResult =
    let ctx2 = extend_context(ctx, param, param_ty) in
    case check_expr(ctx2, body) of
    | TypeOk(body_ty, ctx3) ->
        // Check if parameter was used (if linear)
        if is_linear_type(param_ty) then
            case check_param_used(ctx3, param) of
            | TypeOk(_, _) ->
                TypeOk(TyFun(param_ty, body_ty), ctx)
            | TypeError(msg, line, col) ->
                TypeError(msg, line, col)
            end
        else
            TypeOk(TyFun(param_ty, body_ty), ctx)
    | TypeError(msg, line, col) ->
        TypeError(msg, line, col)
    end

// Check if parameter was used (for linear params)
fn check_param_used(ctx: Context, param: String): TypeResult =
    check_param_used_loop(ctx, param, 0)

fn check_param_used_loop(ctx: Context, param: String, idx: I32): TypeResult =
    if idx >= list_len(ctx.vars) then
        let msg = String.concat(
            String.new@default("Parameter not found: "),
            param
        ) in
        TypeError(msg, 0, 0)
    else
        let entry = list_get(ctx.vars, idx) in
        if string_eq(entry.name, param) then
            if entry.used then
                TypeOk(TyUnit, ctx)
            else
                let msg = String.concat(
                    String.new@default("Linear parameter not used: "),
                    param
                ) in
                TypeError(msg, 0, 0)
        else
            check_param_used_loop(ctx, param, idx + 1)

// Type check function application: f e
fn check_app(ctx: Context, func: Expr, arg: Expr): TypeResult =
    case check_expr(ctx, func) of
    | TypeOk(func_ty, ctx2) ->
        case func_ty of
        | TyFun(param_ty, ret_ty) ->
            case check_expr(ctx2, arg) of
            | TypeOk(arg_ty, ctx3) ->
                if type_eq(param_ty, arg_ty) then
                    TypeOk(ret_ty, ctx3)
                else
                    TypeError(String.new@default("Argument type mismatch"), 0, 0)
            | TypeError(msg, line, col) ->
                TypeError(msg, line, col)
            end
        | _ ->
            TypeError(String.new@default("Expected function type"), 0, 0)
        end
    | TypeError(msg, line, col) ->
        TypeError(msg, line, col)
    end

// Type check if expression: if e1 then e2 else e3
fn check_if(ctx: Context, cond: Expr, then_branch: Expr, else_branch: Expr): TypeResult =
    case check_expr(ctx, cond) of
    | TypeOk(cond_ty, ctx2) ->
        if type_eq(cond_ty, TyBool) then
            // Check both branches with fresh context
            case check_expr(ctx2, then_branch) of
            | TypeOk(then_ty, ctx_then) ->
                case check_expr(ctx2, else_branch) of
                | TypeOk(else_ty, ctx_else) ->
                    if type_eq(then_ty, else_ty) then
                        // TODO: Check branch linearity agreement
                        TypeOk(then_ty, ctx2)
                    else
                        TypeError(String.new@default("Branch type mismatch"), 0, 0)
                | TypeError(msg, line, col) ->
                    TypeError(msg, line, col)
                end
            | TypeError(msg, line, col) ->
                TypeError(msg, line, col)
            end
        else
            TypeError(String.new@default("Condition must be Bool"), 0, 0)
    | TypeError(msg, line, col) ->
        TypeError(msg, line, col)
    end

// Type check pair: (e1, e2)
fn check_pair(ctx: Context, left: Expr, right: Expr): TypeResult =
    case check_expr(ctx, left) of
    | TypeOk(left_ty, ctx2) ->
        case check_expr(ctx2, right) of
        | TypeOk(right_ty, ctx3) ->
            TypeOk(TyProd(left_ty, right_ty), ctx3)
        | TypeError(msg, line, col) ->
            TypeError(msg, line, col)
        end
    | TypeError(msg, line, col) ->
        TypeError(msg, line, col)
    end

// Type check first projection: e.0
fn check_fst(ctx: Context, expr: Expr): TypeResult =
    case check_expr(ctx, expr) of
    | TypeOk(ty, ctx2) ->
        case ty of
        | TyProd(left_ty, _) ->
            TypeOk(left_ty, ctx2)
        | _ ->
            TypeError(String.new@default("Expected product type"), 0, 0)
        end
    | TypeError(msg, line, col) ->
        TypeError(msg, line, col)
    end

// Type check second projection: e.1
fn check_snd(ctx: Context, expr: Expr): TypeResult =
    case check_expr(ctx, expr) of
    | TypeOk(ty, ctx2) ->
        case ty of
        | TyProd(_, right_ty) ->
            TypeOk(right_ty, ctx2)
        | _ ->
            TypeError(String.new@default("Expected product type"), 0, 0)
        end
    | TypeError(msg, line, col) ->
        TypeError(msg, line, col)
    end

// Type check drop: drop(e)
fn check_drop(ctx: Context, expr: Expr): TypeResult =
    case check_expr(ctx, expr) of
    | TypeOk(ty, ctx2) ->
        if is_linear_type(ty) then
            // Linear value consumed by drop
            TypeOk(TyUnit, ctx2)
        else
            // Dropping unrestricted value is unnecessary but allowed
            TypeOk(TyUnit, ctx2)
    | TypeError(msg, line, col) ->
        TypeError(msg, line, col)
    end

// Type check binary operation: e1 op e2
fn check_binop(ctx: Context, op: BinOp, left: Expr, right: Expr): TypeResult =
    case check_expr(ctx, left) of
    | TypeOk(left_ty, ctx2) ->
        case check_expr(ctx2, right) of
        | TypeOk(right_ty, ctx3) ->
            // Check operand types match
            if type_eq(left_ty, right_ty) then
                case op of
                | OpAdd -> TypeOk(left_ty, ctx3)
                | OpSub -> TypeOk(left_ty, ctx3)
                | OpMul -> TypeOk(left_ty, ctx3)
                | OpDiv -> TypeOk(left_ty, ctx3)
                | OpMod -> TypeOk(left_ty, ctx3)
                | OpLt -> TypeOk(TyBool, ctx3)
                | OpLe -> TypeOk(TyBool, ctx3)
                | OpGt -> TypeOk(TyBool, ctx3)
                | OpGe -> TypeOk(TyBool, ctx3)
                | OpEq -> TypeOk(TyBool, ctx3)
                | OpNe -> TypeOk(TyBool, ctx3)
                | OpAnd -> TypeOk(TyBool, ctx3)
                | OpOr -> TypeOk(TyBool, ctx3)
                end
            else
                TypeError(String.new@default("Operand type mismatch"), 0, 0)
        | TypeError(msg, line, col) ->
            TypeError(msg, line, col)
        end
    | TypeError(msg, line, col) ->
        TypeError(msg, line, col)
    end

// Type check list literal: [e1, e2, e3]
fn check_list_lit(ctx: Context, elements: [Expr]): TypeResult =
    if list_len(elements) == 0 then
        // Empty list - default to [I32]
        TypeOk(TyList(TyI32), ctx)
    else
        // Check first element
        let first = list_get(elements, 0) in
        case check_expr(ctx, first) of
        | TypeOk(elem_ty, ctx2) ->
            // Check all elements have same type
            case check_list_elements(ctx2, elements, 1, elem_ty) of
            | TypeOk(_, ctx3) ->
                TypeOk(TyList(elem_ty), ctx3)
            | TypeError(msg, line, col) ->
                TypeError(msg, line, col)
            end
        | TypeError(msg, line, col) ->
            TypeError(msg, line, col)
        end

// Helper: check all list elements have consistent type
fn check_list_elements(ctx: Context, elements: [Expr], idx: I32, expected_ty: Type): TypeResult =
    if idx >= list_len(elements) then
        TypeOk(TyUnit, ctx)
    else
        let elem = list_get(elements, idx) in
        case check_expr(ctx, elem) of
        | TypeOk(elem_ty, ctx2) ->
            if type_eq(elem_ty, expected_ty) then
                check_list_elements(ctx2, elements, idx + 1, expected_ty)
            else
                TypeError(String.new@default("List element type mismatch"), 0, 0)
        | TypeError(msg, line, col) ->
            TypeError(msg, line, col)
        end

// Type check list index: list[idx]
fn check_list_index(ctx: Context, list: Expr, index: Expr): TypeResult =
    case check_expr(ctx, list) of
    | TypeOk(list_ty, ctx2) ->
        case list_ty of
        | TyList(elem_ty) ->
            case check_expr(ctx2, index) of
            | TypeOk(idx_ty, ctx3) ->
                if type_eq(idx_ty, TyI32) then
                    TypeOk(elem_ty, ctx3)
                else
                    TypeError(String.new@default("Index must be I32"), 0, 0)
            | TypeError(msg, line, col) ->
                TypeError(msg, line, col)
            end
        | _ ->
            TypeError(String.new@default("Expected list type"), 0, 0)
        end
    | TypeError(msg, line, col) ->
        TypeError(msg, line, col)
    end

// Main expression type checker
fn check_expr(ctx: Context, expr: Expr): TypeResult =
    case expr of
    | ExLit(lit) -> check_literal(ctx, lit)
    | ExVar(name) -> check_var(ctx, name)
    | ExLet(name, value, body) -> check_let(ctx, name, value, body)
    | ExLetLin(name, value, body) -> check_let_lin(ctx, name, value, body)
    | ExLam(param, param_ty, body) -> check_lambda(ctx, param, param_ty, body)
    | ExApp(func, arg) -> check_app(ctx, func, arg)
    | ExIf(cond, then_br, else_br) -> check_if(ctx, cond, then_br, else_br)
    | ExPair(left, right) -> check_pair(ctx, left, right)
    | ExFst(e) -> check_fst(ctx, e)
    | ExSnd(e) -> check_snd(ctx, e)
    | ExDrop(e) -> check_drop(ctx, e)
    | ExBinOp(op, left, right) -> check_binop(ctx, op, left, right)
    | ExListLit(elements) -> check_list_lit(ctx, elements)
    | ExListIndex(list, idx) -> check_list_index(ctx, list, idx)
    | _ ->
        // TODO: Other expression forms
        TypeError(String.new@default("Unsupported expression form"), 0, 0)
    end

// ============================================================================
// DECLARATION TYPE CHECKING
// ============================================================================

// Type check function declaration
fn check_fn_decl(ctx: Context, name: String, params: [(String, Type)], ret_ty: Type, body: Expr): TypeResult =
    // Extend context with parameters
    let ctx2 = extend_context_with_params(ctx, params, 0) in

    // Check body
    case check_expr(ctx2, body) of
    | TypeOk(body_ty, ctx3) ->
        if type_eq(body_ty, ret_ty) then
            // Check all linear parameters were used
            case check_all_linear_params_used(ctx3, params, 0) of
            | TypeOk(_, _) ->
                TypeOk(TyUnit, ctx)
            | TypeError(msg, line, col) ->
                TypeError(msg, line, col)
            end
        else
            TypeError(String.new@default("Return type mismatch"), 0, 0)
    | TypeError(msg, line, col) ->
        TypeError(msg, line, col)
    end

// Helper: extend context with all parameters
fn extend_context_with_params(ctx: Context, params: [(String, Type)], idx: I32): Context =
    if idx >= list_len(params) then
        ctx
    else
        let param = list_get(params, idx) in
        let (param_name, param_ty) = param in
        let ctx2 = extend_context(ctx, param_name, param_ty) in
        extend_context_with_params(ctx2, params, idx + 1)

// Helper: check all linear parameters were used
fn check_all_linear_params_used(ctx: Context, params: [(String, Type)], idx: I32): TypeResult =
    if idx >= list_len(params) then
        TypeOk(TyUnit, ctx)
    else
        let param = list_get(params, idx) in
        let (param_name, param_ty) = param in
        if is_linear_type(param_ty) then
            case check_param_used(ctx, param_name) of
            | TypeOk(_, _) ->
                check_all_linear_params_used(ctx, params, idx + 1)
            | TypeError(msg, line, col) ->
                TypeError(msg, line, col)
            end
        else
            check_all_linear_params_used(ctx, params, idx + 1)

// Type check declaration
fn check_decl(ctx: Context, decl: Decl): TypeResult =
    case decl of
    | DeclFn(name, params, ret_ty, body) ->
        check_fn_decl(ctx, name, params, ret_ty, body)
    | DeclType(_, _) ->
        // Type declarations don't need runtime checking
        TypeOk(TyUnit, ctx)
    end

// ============================================================================
// MODULE TYPE CHECKING
// ============================================================================

// Type check entire module
fn check_module(module: Module, mode: Mode): TypeResult =
    let ctx = empty_context(mode) in
    check_module_decls(ctx, module.decls, 0)

// Check all declarations in module
fn check_module_decls(ctx: Context, decls: [Decl], idx: I32): TypeResult =
    if idx >= list_len(decls) then
        TypeOk(TyUnit, ctx)
    else
        let decl = list_get(decls, idx) in
        case check_decl(ctx, decl) of
        | TypeOk(_, ctx2) ->
            check_module_decls(ctx2, decls, idx + 1)
        | TypeError(msg, line, col) ->
            TypeError(msg, line, col)
        end

// ============================================================================
// MAIN ENTRY POINT
// ============================================================================

// Type check a module in linear mode
fn typecheck_linear(module: Module): TypeResult =
    check_module(module, ModeLinear)

// Type check a module in affine mode
fn typecheck_affine(module: Module): TypeResult =
    check_module(module, ModeAffine)
