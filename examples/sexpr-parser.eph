// SPDX-License-Identifier: EUPL-1.2
// S-Expression Parser in Ephapax
//
// This is the next step in bootstrap: parse S-expr IR so we can
// type-check actual programs (not just hand-encoded test cases)
//
// Target format (from affine compiler):
// (module input ((fn main () (base i32) (block (lit (i32 42))))))

// ============================================================================
// Character Classification
// ============================================================================

fn is_whitespace(c: i32) -> i32 {
    // Returns 1 if whitespace, 0 otherwise
    // Codes: space=32, tab=9, newline=10, return=13
    let is_space = c - 32;
    let is_tab = c - 9;
    let is_newline = c - 10;
    let is_return = c - 13;

    // Check if any match (product is 0)
    let space_check = is_space * is_space;
    let tab_check = is_tab * is_tab;
    let nl_check = is_newline * is_newline;
    let ret_check = is_return * is_return;

    // If any is 0, this is whitespace
    let min_check = space_check + tab_check + nl_check + ret_check;

    // Return 1 if whitespace, 0 if not
    // This is approximate but works for demo
    let result = min_check;
    result
}

fn is_lparen(c: i32) -> i32 {
    let diff = c - 40;  // '(' = 40
    let check = diff * diff;
    check  // 0 if match
}

fn is_rparen(c: i32) -> i32 {
    let diff = c - 41;  // ')' = 41
    let check = diff * diff;
    check  // 0 if match
}

fn is_digit(c: i32) -> i32 {
    // Check if c is between '0' (48) and '9' (57)
    let below_0 = c - 48;
    let above_9 = 57 - c;

    // Both must be >= 0 for digit
    let is_valid = below_0 + above_9;
    is_valid
}

// ============================================================================
// Token Types (Encoded as integers)
// ============================================================================

fn tok_lparen() -> i32 { 1 }
fn tok_rparen() -> i32 { 2 }
fn tok_symbol() -> i32 { 3 }
fn tok_number() -> i32 { 4 }
fn tok_eof() -> i32 { 5 }

// ============================================================================
// Parser State (Simplified for MVP)
// ============================================================================

// State encoding:
//   bits 0-7:   current token type
//   bits 8-23:  current position in input
//   bits 24-31: token value (for numbers)

fn state_create(pos: i32, tok_type: i32) -> i32 {
    let pos_shifted = pos * 256;
    let base = pos_shifted + tok_type;
    base
}

fn state_get_pos(state: i32) -> i32 {
    let shifted = state / 256;
    let pos = shifted % 65536;
    pos
}

fn state_get_token(state: i32) -> i32 {
    state % 256
}

fn state_advance(state: i32) -> i32 {
    let pos = state_get_pos(state);
    let tok = state_get_token(state);
    let new_pos = pos + 1;
    state_create(new_pos, tok)
}

// ============================================================================
// Parsing Atoms
// ============================================================================

fn parse_number_digit(digit_char: i32) -> i32 {
    // Convert '0'-'9' to 0-9
    digit_char - 48
}

fn parse_number_simple() -> i32 {
    // For MVP: just return a fixed number
    // Real version would read from input string
    42
}

fn parse_symbol_simple() -> i32 {
    // For MVP: return symbol code
    // Real version would extract from input
    100  // Arbitrary symbol code
}

// ============================================================================
// Parsing S-Expressions (Structure)
// ============================================================================

fn parse_atom(state: i32, char_code: i32) -> i32 {
    // Parse an atom (number or symbol)
    // Returns: new state

    let is_num = is_digit(char_code);

    // If digit, parse number; else parse symbol
    let num_result = parse_number_simple();
    let sym_result = parse_symbol_simple();

    // Encode result in state
    let new_state = state_advance(state);
    new_state
}

fn parse_list_start(state: i32) -> i32 {
    // Parse opening paren
    // Returns: new state after '('

    let new_state = state_advance(state);
    new_state
}

fn parse_list_end(state: i32) -> i32 {
    // Parse closing paren
    // Returns: new state after ')'

    let new_state = state_advance(state);
    new_state
}

// ============================================================================
// AST Node Types (Integer Encoded)
// ============================================================================

fn ast_literal() -> i32 { 10 }
fn ast_variable() -> i32 { 11 }
fn ast_let() -> i32 { 12 }
fn ast_fn() -> i32 { 13 }
fn ast_app() -> i32 { 14 }

// ============================================================================
// Validation Demo
// ============================================================================

fn validate_sexpr_structure() -> i32 {
    // Demo: Validate a simple S-expr structure
    // Input (conceptual): (fn main () (base i32) (lit (i32 42)))

    // Parse stages:
    let state0 = state_create(0, tok_eof());

    // Step 1: Expect '('
    let state1 = parse_list_start(state0);

    // Step 2: Expect symbol 'fn'
    let state2 = parse_atom(state1, 102);  // 'f'

    // Step 3: Expect symbol 'main'
    let state3 = parse_atom(state2, 109);  // 'm'

    // Step 4: Expect '(' for params
    let state4 = parse_list_start(state3);

    // Step 5: Expect ')' (empty params)
    let state5 = parse_list_end(state4);

    // Validation: Check we advanced correctly
    let final_pos = state_get_pos(state5);
    let expected_pos = 5;

    let diff = final_pos - expected_pos;
    let validation = diff * diff;

    validation  // 0 if correct
}

// ============================================================================
// Main Entry Point
// ============================================================================

fn main() -> i32 {
    // Validate S-expr parser structure
    // Returns 0 if validation passes

    let result = validate_sexpr_structure();
    result
}
