// SPDX-License-Identifier: PMPL-1.0-or-later
// Advanced Ephapax Features
//
// Demonstrates product types, sum types, lambdas, and borrows

// ============================================================================
// Product Types (Pairs and Tuples)
// ============================================================================

// Simple pair creation and access
fn pair_basics(_unit: ()): I32 =
    let p = (10, 20) in
    let x = p.0 in
    let y = p.1 in
    x + y

// Nested pairs
fn nested_pairs(_unit: ()): I32 =
    let p1 = (1, 2) in
    let p2 = (3, 4) in
    let nested = (p1, p2) in
    let first_pair = nested.0 in
    let a = first_pair.0 in
    let b = first_pair.1 in
    a + b

// Pair swapping
fn swap_pair(p: (I32, I32)): (I32, I32) =
    let x = p.0 in
    let y = p.1 in
    (y, x)

// ============================================================================
// Lambda Expressions
// ============================================================================

// Basic lambda
fn apply_lambda(_unit: ()): I32 =
    let increment = fn (x: I32) -> x + 1 in
    let result = increment(5) in
    result

// Lambda with multiple operations
fn complex_lambda(_unit: ()): I32 =
    let compute = fn (x: I32) ->
        let doubled = x * 2 in
        let incremented = doubled + 1 in
        incremented
    in
    compute(10)

// Using lambdas for abstraction
fn apply_twice(f: I32 -> I32, x: I32): I32 =
    let once = f(x) in
    f(once)

fn lambda_composition(_unit: ()): I32 =
    let add_five = fn (n: I32) -> n + 5 in
    apply_twice(add_five, 0)

// ============================================================================
// Borrow Checking
// ============================================================================

// Borrowing allows reading without consuming
fn borrow_example(_unit: ()): I32 =
    region r {
        let s = String.new@r("hello") in

        // Borrow for reading (doesn't consume)
        let len1 = String.len(&s) in

        // Can borrow multiple times
        let len2 = String.len(&s) in

        // Finally consume
        let _ = drop(s) in

        len1 + len2
    }

// Multiple borrows in sequence
fn multiple_borrows(_unit: ()): I32 =
    region r {
        let s = String.new@r("test") in

        let len = String.len(&s) in
        let len_again = String.len(&s) in
        let len_third = String.len(&s) in

        let _ = drop(s) in
        len + len_again + len_third
    }

// ============================================================================
// Combining Features
// ============================================================================

// Pairs with lambdas
fn pair_with_lambda(_unit: ()): I32 =
    let p = (5, 3) in
    let process = fn (pair: (I32, I32)) ->
        let x = pair.0 in
        let y = pair.1 in
        x * y
    in
    process(p)

// Region with pairs and borrows
fn complex_region(_unit: ()): I32 =
    region r {
        let s1 = String.new@r("first") in
        let s2 = String.new@r("second") in

        let len1 = String.len(&s1) in
        let len2 = String.len(&s2) in

        let pair = (len1, len2) in
        let sum = pair.0 + pair.1 in

        let _ = drop(s1) in
        let _ = drop(s2) in

        sum
    }

// ============================================================================
// Practical Example: Data Pipeline
// ============================================================================

fn process_data(input: I32): I32 =
    // Stage 1: Transform
    let transformed = fn (x: I32) -> x * 2 in
    let stage1 = transformed(input) in

    // Stage 2: Filter (as conditional)
    let stage2 = if stage1 > 10 then stage1 else 0 in

    // Stage 3: Aggregate
    let finalize = fn (x: I32) -> x + 100 in
    finalize(stage2)

fn pipeline_example(_unit: ()): I32 =
    let data = (5, 10, 15) in

    let r1 = process_data(data.0) in
    let r2 = process_data(data.1) in
    let r3 = process_data(data.2) in

    r1 + r2 + r3

// ============================================================================
// Main: Run all examples
// ============================================================================

fn main(_unit: ()): I32 =
    let ex1 = pair_basics(()) in
    let ex2 = nested_pairs(()) in
    let ex3 = apply_lambda(()) in
    let ex4 = complex_lambda(()) in
    let ex5 = borrow_example(()) in
    let ex6 = pair_with_lambda(()) in
    let ex7 = pipeline_example(()) in

    ex1 + ex2 + ex3 + ex4 + ex5 + ex6 + ex7
