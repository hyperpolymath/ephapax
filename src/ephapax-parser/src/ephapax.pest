// SPDX-License-Identifier: EUPL-1.2
// SPDX-FileCopyrightText: 2025 Jonathan D.A. Jewell

// ============================================================================
// Ephapax Grammar - PEG Parser
// ============================================================================

// Top-level rules
module = { SOI ~ declaration* ~ EOI }
expression_only = { SOI ~ expression ~ EOI }

// ============================================================================
// Declarations
// ============================================================================

declaration = { fn_decl | type_decl }

fn_decl = {
    "fn" ~ identifier ~ "(" ~ param_list? ~ ")" ~ ":" ~ ty ~ "=" ~ expression
}

param_list = { param ~ ("," ~ param)* }

param = { identifier ~ ":" ~ ty }

type_decl = { "type" ~ identifier ~ "=" ~ ty }

// ============================================================================
// Types
// ============================================================================

ty = { sum_ty ~ ("->" ~ ty)? }

sum_ty = { type_atom ~ ("+" ~ type_atom)* }

type_atom = {
    base_ty
    | string_ty
    | borrow_ty
    | product_ty
    | type_var
}

base_ty = { unit_ty | "Bool" | "I32" | "I64" | "F32" | "F64" }
unit_ty = { "()" }

string_ty = { "String" ~ "@" ~ identifier }

borrow_ty = { "&" ~ type_atom }

product_ty = { "(" ~ ty ~ ("," ~ ty)+ ~ ")" }

type_var = { identifier }

// ============================================================================
// Expressions
// ============================================================================

expression = {
    let_expr
    | let_lin_expr
    | lambda_expr
    | if_expr
    | region_expr
    | case_expr
    | or_expr
}

let_expr = {
    "let" ~ identifier ~ (":" ~ ty)? ~ "=" ~ expression ~ "in" ~ expression
}

let_lin_expr = {
    "let!" ~ identifier ~ (":" ~ ty)? ~ "=" ~ expression ~ "in" ~ expression
}

lambda_expr = {
    "fn" ~ "(" ~ identifier ~ ":" ~ ty ~ ")" ~ "->" ~ expression
}

if_expr = {
    "if" ~ expression ~ "then" ~ expression ~ "else" ~ expression
}

region_expr = {
    "region" ~ identifier ~ "{" ~ expression ~ "}"
}

case_expr = {
    "case" ~ expression ~ "of"
    ~ "inl" ~ "(" ~ identifier ~ ")" ~ "->" ~ expression
    ~ "inr" ~ "(" ~ identifier ~ ")" ~ "->" ~ expression
    ~ "end"
}

// ============================================================================
// Binary Operators (by precedence, lowest to highest)
// ============================================================================

or_expr = { and_expr ~ ("||" ~ and_expr)* }

and_expr = { eq_expr ~ ("&&" ~ eq_expr)* }

eq_expr = { cmp_expr ~ (eq_op ~ cmp_expr)* }
eq_op = { "==" | "!=" }

cmp_expr = { add_expr ~ (cmp_op ~ add_expr)* }
cmp_op = { "<=" | ">=" | "<" | ">" }

add_expr = { mul_expr ~ (add_op ~ mul_expr)* }
add_op = { "+" | "-" }

mul_expr = { unary_expr ~ (mul_op ~ unary_expr)* }
mul_op = { "*" | "/" | "%" }

// ============================================================================
// Unary and Postfix Expressions
// ============================================================================

unary_expr = {
    "!" ~ unary_expr
    | "-" ~ unary_expr
    | postfix_expr
}

postfix_expr = { atom_expr ~ postfix_op* }

postfix_op = {
    call_op
    | member_op
}

call_op = { "(" ~ expression ~ ")" }
member_op = { "." ~ (integer | identifier) }

// ============================================================================
// Atomic Expressions
// ============================================================================

atom_expr = {
    string_method
    | inl_expr
    | inr_expr
    | borrow_expr
    | drop_expr
    | copy_expr
    | paren_or_pair
    | literal
    | variable
}

string_method = {
    "String" ~ "." ~ identifier ~ ("@" ~ identifier)? ~ "(" ~ expr_list? ~ ")"
}

expr_list = { expression ~ ("," ~ expression)* }

inl_expr = { "inl" ~ "[" ~ ty ~ "]" ~ "(" ~ expression ~ ")" }
inr_expr = { "inr" ~ "[" ~ ty ~ "]" ~ "(" ~ expression ~ ")" }

borrow_expr = { "&" ~ unary_expr }

drop_expr = { "drop" ~ "(" ~ expression ~ ")" }
copy_expr = { "copy" ~ "(" ~ expression ~ ")" }

paren_or_pair = { "(" ~ (expression ~ ("," ~ expression)*)? ~ ")" }

variable = { identifier }

// ============================================================================
// Literals
// ============================================================================

literal = {
    unit_literal
    | boolean
    | float
    | integer
    | string
}

unit_literal = { "()" }
boolean = { "true" | "false" }

integer = @{ ASCII_DIGIT+ }
float = @{ ASCII_DIGIT+ ~ "." ~ ASCII_DIGIT+ }

string = @{ "\"" ~ string_inner ~ "\"" }
string_inner = @{ (escape | !("\"" | "\\") ~ ANY)* }
escape = @{ "\\" ~ ("n" | "r" | "t" | "\\" | "\"") }

// ============================================================================
// Identifiers and Whitespace
// ============================================================================

identifier = @{
    !keyword ~ (ASCII_ALPHA | "_") ~ (ASCII_ALPHANUMERIC | "_")*
}

keyword = {
    "let" | "let!" | "in" | "fn" | "if" | "then" | "else"
    | "region" | "case" | "of" | "inl" | "inr" | "end"
    | "drop" | "copy" | "type" | "true" | "false"
    | "Bool" | "I32" | "I64" | "F32" | "F64" | "String"
}

WHITESPACE = _{ " " | "\t" | "\n" | "\r" }
COMMENT = _{ "//" ~ (!"\n" ~ ANY)* | "/*" ~ (!"*/" ~ ANY)* ~ "*/" }
