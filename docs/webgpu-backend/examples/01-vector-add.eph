// SPDX-License-Identifier: EUPL-1.2
// Example 01: Vector Addition with Linear GPU Buffers
//
// This example demonstrates:
// - Creating linear GPU buffers
// - Transferring data to GPU
// - Running a simple kernel
// - Linear type enforcement

// GPU kernel: add two vectors
@gpu
fn vector_add!(
    a: GPUBuffer<f32>!,
    b: GPUBuffer<f32>!,
    n: usize
) -> GPUBuffer<f32>! {
    // Allocate result buffer
    region gpu:
        let! result = allocate_gpu@gpu(n * sizeof<f32>());

        // Dispatch kernel
        dispatch {
            workgroup_size: [256, 1, 1],
            workgroup_count: [(n + 255) / 256, 1, 1],
            shader: |gid| {
                if gid < n {
                    result[gid] = a[gid] + b[gid];
                }
            }
        };

        // Linear types ensure a, b, result properly managed
        result
}

// Main function
fn main() -> i32 {
    let n = 1024;

    // Create host data
    let! a_host = vec_range(0.0, 1024.0);
    let! b_host = vec_range(1000.0, 2024.0);

    // Transfer to GPU (linear)
    region gpu:
        let! a_gpu = h2d(a_host);  // Consumes a_host
        let! b_gpu = h2d(b_host);  // Consumes b_host

        // Compute on GPU
        let! result_gpu = vector_add(a_gpu, b_gpu, n);

        // Transfer back to CPU
        let! result_host = d2h(result_gpu);

        // Verify result
        print("Result[0]: ");
        print_f32(result_host[0]);  // Should be 1000.0
        print("\n");

        // All GPU buffers automatically freed here
        drop(result_host);
        0
}

// Helper: create range vector
fn vec_range(start: f32, end: f32) -> Vec<f32>! {
    let n = ((end - start) as usize);
    let! vec = allocate_vec(n);

    for i in 0..n {
        vec[i] = start + (i as f32);
    }

    vec
}
