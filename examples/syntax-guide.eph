// SPDX-License-Identifier: PMPL-1.0-or-later
// Ephapax Syntax Guide and Examples
//
// This file demonstrates the correct Ephapax syntax.
// Note: Ephapax uses ML-style syntax, not C-style syntax.

// ============================================================================
// Function Declarations
// ============================================================================

// Simple function (no parameters)
fn constant_value(): I32 = 42

// Function with parameters
fn add(x: I32, y: I32): I32 = x + y

// Function with let bindings (use 'in' keyword)
fn compute(_unit: ()): I32 =
    let x = 10 in
    let y = 20 in
    x + y

// Nested let bindings
fn nested(_unit: ()): I32 =
    let a = 1 in
    let b = 2 in
    let c = a + b in
    let d = c * 2 in
    d

// ============================================================================
// If Expressions
// ============================================================================

fn conditional(x: I32): I32 =
    if x > 0 then x else 0

fn complex_conditional(_unit: ()): I32 =
    let x = 10 in
    let y = 20 in
    if x < y then
        let sum = x + y in
        sum
    else
        let diff = y - x in
        diff

// ============================================================================
// Lambda Expressions
// ============================================================================

fn use_lambda(_unit: ()): I32 =
    let f = fn (x: I32) -> x + 1 in
    f(5)

// Note: Higher-order functions with function type parameters
// require more complex type annotations - simplified for now

// ============================================================================
// Product Types (Pairs)
// ============================================================================

fn make_pair(_unit: ()): (I32, I32) = (10, 20)

fn pair_operations(_unit: ()): I32 =
    let p = (5, 3) in
    let x = p.0 in
    let y = p.1 in
    x + y

// ============================================================================
// Linear Types (with regions)
// ============================================================================

// Linear values must be consumed exactly once
fn linear_example(_unit: ()): I32 =
    region r {
        let s = String.new@r("hello") in
        let len = String.len(&s) in
        let _ = drop(s) in
        len
    }

// ============================================================================
// Main Entry Point
// ============================================================================

fn main(_unit: ()): I32 =
    let result = compute(()) in
    let cond_result = conditional(5) in
    let lambda_result = use_lambda(()) in
    result + cond_result + lambda_result
