# ⚠️ STOP - CRITICAL READING REQUIRED

**THIS FILE MUST BE READ FIRST BY ALL AI AGENTS**

## WHAT IS THIS?

This is the AI manifest for **ephapax** — a dyadic language with linear and affine type systems. It declares:
- Canonical file locations (where things MUST be, and nowhere else)
- Critical invariants (rules that must NEVER be violated)
- Repository structure and organization
- Dyadic language design (affine vs. linear modes)

## CANONICAL LOCATIONS (UNIVERSAL RULE)

### Machine-Readable Metadata: `.machine_readable/` ONLY

These 6 SCM files MUST exist in `.machine_readable/` directory ONLY:
1. **STATE.scm** - Project state, progress, blockers
2. **META.scm** - Architecture decisions, governance
3. **ECOSYSTEM.scm** - Position in ecosystem, relationships
4. **AGENTIC.scm** - AI agent interaction patterns
5. **NEUROSYM.scm** - Neurosymbolic integration config
6. **PLAYBOOK.scm** - Operational runbook

**CRITICAL:** If ANY of these files exist in `.machine_read/` or the root directory, this is an ERROR.
**LEGACY:** `.machine_read/` is DEPRECATED. All files must migrate to `.machine_readable/`.

### Bot Directives: `.bot_directives/` ONLY

Bot-specific instructions for:
- rhodibot - Git operations
- echidnabot - Code quality
- sustainabot - Dependency updates
- glambot - Documentation
- seambot - Integration
- finishbot - Task completion

### Agent Instructions

- `.claude/CLAUDE.md` - Claude-specific patterns (if exists)
- `0-AI-MANIFEST.a2ml` - THIS FILE (universal entry point)

## CORE INVARIANTS

1. **No SCM duplication** - Root must NOT contain STATE.scm, META.scm, etc.
2. **Single source of truth** - `.machine_readable/` is authoritative
3. **No stale metadata** - If root or `.machine_read/` SCMs exist, they are OUT OF DATE
4. **License consistency** - All code PMPL-1.0-or-later (was EUPL-1.2, updated)
5. **Author attribution** - Always "Jonathan D.A. Jewell <jonathan.jewell@open.ac.uk>"
6. **Dyadic design** - Language supports BOTH affine and linear modes (not mutually exclusive)

## DYADIC LANGUAGE DESIGN (CRITICAL CONCEPT)

Ephapax is a **dyadic language** with TWO type system modes:

### Affine Mode (Permissive)
- Values can be used **at most once** (0 or 1 times)
- **Can be dropped/ignored** without error
- Suitable for: prototyping, exploration, optional resource cleanup
- Trade-off: More flexible, less safety guarantees
- Compilation: `just compile-affine input.eph affine output.wasm`

### Linear Mode (Strict)
- Values MUST be used **exactly once** (1 time only)
- **Cannot be dropped** - compiler error if unused
- Suitable for: resource safety, connection management, memory leak prevention
- Trade-off: Stricter, stronger guarantees
- Compilation: (To be implemented with same pipeline)

### Dyadic Philosophy
- **Not a migration path** - Both modes are first-class citizens
- **Use case driven** - Choose mode based on requirements, not maturity
- **Same syntax** - Language features identical, only type system strictness differs
- **Mode switching** - Code can be checked in either mode via `--mode` flag

## REPOSITORY STRUCTURE

This repo contains a **two-stage compiler**:

```
ephapax/
├── 0-AI-MANIFEST.a2ml          # THIS FILE (start here)
├── README.adoc                  # Project overview
├── Cargo.toml                   # Rust workspace configuration
├── justfile                     # Build commands
│
├── idris2/                      # Stage 1: Idris2 affine/linear type checker
│   ├── ephapax-affine.ipkg     # Idris2 package (handles BOTH modes)
│   ├── src/                     # Idris2 source (parser, type checker)
│   └── build/                   # Compiled Idris2 binary
│
├── src/                         # Stage 2: Rust WASM compiler (11 crates)
│   ├── ephapax-syntax/          # AST definitions
│   ├── ephapax-ir/              # S-expression IR
│   ├── ephapax-lexer/           # Tokenizer (logos)
│   ├── ephapax-parser/          # Parser (chumsky)
│   ├── ephapax-typing/          # Type checker (Rust implementation)
│   ├── ephapax-interp/          # Tree-walking interpreter
│   ├── ephapax-wasm/            # WASM code generation
│   ├── ephapax-runtime/         # Runtime support
│   ├── ephapax-stdlib/          # Standard library
│   ├── ephapax-repl/            # Interactive shell
│   └── ephapax-cli/             # Command-line interface
│
├── ephapax-linear/              # Linear mode specification & docs
│   ├── docs/                    # Linear semantics documentation
│   ├── grammar/                 # Linear mode grammar
│   └── src/                     # Linear-specific examples
│
├── ephapax-proven/              # Coq-verified components
│   └── (Subproject with formal proofs)
│
├── formal/                      # Coq formalization
│   ├── Syntax.v                 # AST and types
│   ├── Typing.v                 # Linear typing rules
│   └── Semantics.v              # Operational semantics & soundness
│
├── examples/                    # Example programs (affine & linear)
├── conformance/                 # Type system conformance tests
│   ├── pass/                    # Valid programs
│   └── fail/                    # Invalid programs (must be rejected)
│
├── .machine_readable/           # SCM files (6 files)
│   ├── STATE.scm
│   ├── META.scm
│   ├── ECOSYSTEM.scm
│   ├── AGENTIC.scm
│   ├── NEUROSYM.scm
│   └── PLAYBOOK.scm
│
└── .bot_directives/             # Bot instructions
```

## COMPILATION PIPELINE

### Current (Idris2 + Rust)
```
input.eph
  → [Idris2: parse + typecheck in affine/linear mode]
  → IR (S-expression)
  → [Rust: WASM codegen]
  → output.wasm
```

**Key commands:**
- `just idris-build` - Build Idris2 stage
- `just compile-affine input.eph affine output.wasm` - Full pipeline (affine)
- `just smoke` - End-to-end test
- `just build` - Build Rust stage only

## SESSION STARTUP CHECKLIST

✅ Read THIS file (0-AI-MANIFEST.a2ml) first
✅ Understand **dyadic design** (affine vs. linear, both are first-class)
✅ Understand canonical locations (.machine_readable/, not .machine_read/)
✅ Know the invariants (no SCM duplication, etc.)
✅ Check for MCP enforcement (if applicable)
✅ Read `.machine_readable/STATE.scm` for current status
✅ Read `.machine_readable/AGENTIC.scm` for interaction patterns
✅ Check type checker completion status (currently 60%)
✅ Check WASM codegen completion status (currently 30%)

## LIFECYCLE HOOKS

### on-enter (Session Start)

When starting a new session:

1. Read and acknowledge this manifest
2. Log session start (optional but recommended)
   - Format: `[YYYY-MM-DD HH:MM:SS] Session started: [agent-name]`
   - Location: `.machine_readable/session-log.txt`
3. Read `.machine_readable/STATE.scm`
4. Check for blockers (type checker, WASM codegen)
5. State understanding of canonical locations AND dyadic design
6. Identify which mode (affine/linear) work applies to

### on-exit (Session End)

When ending a session:

1. Update `.machine_readable/STATE.scm` if changes made
2. Update completion percentages (type checker, WASM codegen)
3. Log session end (optional but recommended)
   - Format: `[YYYY-MM-DD HH:MM:SS] Session ended: [summary]`
   - Location: `.machine_readable/session-log.txt`
4. Document new blockers
5. Summarize outcomes for BOTH modes if applicable

## CRITICAL WORK IN PROGRESS

**Type Checker (60% complete):**
- ✅ Branch agreement verification
- ✅ Borrow validity checking
- ⚠️  Linear context threading (partial)
- ❌ Region scope tracking (incomplete)
- ❌ Affine mode support (planned)

**WASM Codegen (30% complete):**
- ⚠️  Primitives codegen (in progress)
- ⚠️  Functions codegen (in progress)
- ❌ Products/sums codegen (planned)
- ❌ Regions codegen (planned)
- ❌ Linear memory management (planned)

**Target:** Make ephapax as complete as phronesis (working binary, full CLI, LSP, examples, docs)

## ATTESTATION PROOF

After reading this file, demonstrate understanding by stating:

**"I have read the AI manifest. SCM files are located in `.machine_readable/` ONLY (not `.machine_read/`), bot directives in `.bot_directives/`, and I understand the dyadic design (affine vs. linear modes are both first-class). I will not create duplicate files in the root directory."**

## META

- **Format Version:** 1.0.0
- **Created:** 2026-02-07
- **Maintained By:** hyperpolymath
- **License:** PMPL-1.0-or-later (was EUPL-1.2, updated)
- **Protocol:** https://github.com/hyperpolymath/0-ai-gatekeeper-protocol
- **Completion Status:** 40% overall (type checker 60%, WASM codegen 30%)
