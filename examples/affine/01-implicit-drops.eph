// SPDX-License-Identifier: PMPL-1.0-or-later
// Affine Mode Example: Implicit Drops Allowed
//
// In affine mode, linear values can be left unconsumed.
// This is useful for prototyping and exploration where strict
// resource tracking isn't required.

// Example 1: Unconsumed string (allowed in affine mode)
fn create_and_ignore(_unit: ()): I32 =
    region r {
        let s = String.new@r("hello") in
        42
    }
    // Note: 's' is not explicitly dropped
    // Affine mode allows implicit drops at scope exit

// Example 2: Conditional computation (still must agree on consumption)
fn conditional_use(should_use: Bool): I32 =
    region r {
        let s = String.new@r("data") in
        let result = if should_use then
            String.len(&s)
        else
            0
        in
        // 's' not consumed in either branch
        // Affine mode allows implicit drop here
        result
    }

// Example 3: Multiple resources, partial consumption
fn partial_cleanup(_unit: ()): I32 =
    region r {
        let s1 = String.new@r("first") in
        let s2 = String.new@r("second") in
        let s3 = String.new@r("third") in

        // Only drop s2 explicitly
        let _ = drop(s2) in

        // s1 and s3 are implicitly dropped
        100
    }

// Example 4: Simple unconsumed resource
fn simple_cleanup(flag: Bool): I32 =
    region r {
        let resource = String.new@r("important") in

        let result = if flag then
            42
        else
            String.len(&resource)
        in

        // Resource not consumed in either branch
        // Affine mode allows implicit drop
        result
    }

// Main: demonstrate affine flexibility
fn main(_unit: ()): I32 =
    let r1 = create_and_ignore(()) in
    let r2 = conditional_use(true) in
    let r3 = partial_cleanup(()) in
    let r4 = simple_cleanup(false) in
    r1 + r2 + r3 + r4
